/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.6.5. DO NOT MODIFY.
*/
`timescale 100fs/100fs
module testBench
    ( // No inputs

      // Outputs
      output wire  result
    );
  wire [2:0] c$ds_app_arg;
  wire [4:0] c$ds_app_arg_0;
  reg [2:0] s = 3'd0;
  // ../clique4.hs:82:5-7
  wire  \BitLogicCliqueWithBuffAndCounter.testBench_clk ;
  wire [3:0] z;
  wire [2:0] result_1;
  wire [5:0] c$ds_app_arg_1;
  wire  c$result_rec;
  reg [2:0] s_0 = 3'd0;
  wire  f2;
  reg  \f'  = 1'b0;
  // ../clique4.hs:(45,1)-(48,46)
  reg [3:0] c$ds_app_arg_2 = {2'd1,   1'b0,   1'b0};
  wire [5:0] result_2;
  reg [1:0] c$app_arg;
  wire  c$case_alt;
  reg  c$app_arg_0;
  wire [9:0] result_3;
  // ../clique4.hs:28:1-35
  wire [1:0] cnt;
  // ../clique4.hs:28:1-35
  wire  prev1;
  // ../clique4.hs:28:1-35
  wire  prev2;
  // ../clique4.hs:28:1-35
  wire  complexOrSimple;
  // ../clique4.hs:11:1-32
  wire  p;
  // ../clique4.hs:11:1-32
  wire  q;
  // ../clique4.hs:11:1-32
  wire  r;
  // ../clique4.hs:11:1-32
  wire  s_1;
  // ../clique4.hs:11:1-32
  wire  t;
  // ../clique4.hs:11:1-32
  wire  xorResult;
  // ../clique4.hs:11:1-32
  wire  common;
  wire [4:0] result_4;
  // ../clique4.hs:61:1-9
  wire  \c$BitLogicCliqueWithBuffAndCounter.testBench_bindCsr ;
  wire [29:0] c$vecFlat;
  wire [35:0] c$vecFlat_0;

  assign c$ds_app_arg = (s < 3'd5) ? (s + 3'd1) : s;

  assign c$vecFlat = {{1'b0,   1'b0,   1'b0,
                       1'b0,   1'b0},   {1'b1,   1'b1,   1'b0,
                                         1'b0,   1'b1},   {1'b1,   1'b0,   1'b1,
                                                           1'b0,   1'b1},   {1'b0,   1'b0,   1'b0,
                                                                             1'b0,   1'b0},   {1'b0,   1'b0,   1'b0,
                                                                                               1'b0,   1'b0},   {1'b0,
                                                                                                                 1'b0,
                                                                                                                 1'b0,
                                                                                                                 1'b0,
                                                                                                                 1'b0}};

  // index begin
  wire [4:0] vecArray [0:6-1];
  genvar i;
  generate
  for (i=0; i < 6; i=i+1) begin : mk_array
    assign vecArray[(6-1)-i] = c$vecFlat[i*5+:5];
  end
  endgenerate
  assign c$ds_app_arg_0 = vecArray[($unsigned({{(64-3) {1'b0}},s}))];
  // index end

  // register begin
  always @(posedge \BitLogicCliqueWithBuffAndCounter.testBench_clk  or  posedge  \c$BitLogicCliqueWithBuffAndCounter.testBench_bindCsr ) begin : s_register
    if ( \c$BitLogicCliqueWithBuffAndCounter.testBench_bindCsr ) begin
      s <= 3'd0;
    end else begin
      s <= c$ds_app_arg;
    end
  end
  // register end

  // tbClockGen begin
  // pragma translate_off
  reg  clk;
  // 1 = 0.1ps
  localparam half_period = (100000 / 2);
  always begin
    // Delay of 1 mitigates race conditions (https://github.com/steveicarus/iverilog/issues/160)
    #1 clk =  0 ;
    `ifndef VERILATOR
    #100000 forever begin
      if (~ (~ c$result_rec)) begin
        $finish(0);
      end
      clk = ~ clk;
      #half_period;
      clk = ~ clk;
      #half_period;
    end
    `else
    clk = $c("this->tb_clock_gen(",half_period,",true,",(~ (~ c$result_rec)),")");
    `endif
  end

  `ifdef VERILATOR
    `systemc_interface
    CData tb_clock_gen(vluint32_t half_period, bool active_rising, bool result_rec) {
      static vluint32_t init_wait = 100000;
      static vluint32_t to_wait = 0;
      static CData clock = active_rising ? 0 : 1;

      if(init_wait == 0) {
        if(result_rec) {
          std::exit(0);
        }
        else {
          if(to_wait == 0) {
            to_wait = half_period - 1;
            clock = clock == 0 ? 1 : 0;
          }
          else {
            to_wait = to_wait - 1;
          }
        }
      }
      else {
        init_wait = init_wait - 1;
      }

      return clock;
    }
    `verilog
  `endif

  assign \BitLogicCliqueWithBuffAndCounter.testBench_clk  = clk;
  // pragma translate_on
  // tbClockGen end

  assign z = s_0 + 3'd1;

  assign result_1 = (z > 4'd5) ? 3'd5 : (z[0+:3]);

  assign c$vecFlat_0 = {{1'b0,   1'b0,   1'b0,
                         1'b0,   1'b0,   1'b0},   {1'b0,   1'b1,
                                                   1'b0,   1'b0,   1'b0,   1'b0},   {1'b1,
                                                                                     1'b0,   1'b1,   1'b0,   1'b0,
                                                                                     1'b0},   {1'b0,   1'b0,   1'b0,
                                                                                               1'b0,   1'b0,   1'b0},
                        {1'b0,   1'b0,   1'b0,   1'b0,   1'b0,
                         1'b0},   {1'b0,   1'b0,   1'b0,   1'b0,
                                   1'b0,   1'b1}};

  // index begin
  wire [5:0] vecArray_0 [0:6-1];
  genvar i_0;
  generate
  for (i_0=0; i_0 < 6; i_0=i_0+1) begin : mk_array_0
    assign vecArray_0[(6-1)-i_0] = c$vecFlat_0[i_0*6+:6];
  end
  endgenerate
  assign c$ds_app_arg_1 = vecArray_0[($unsigned({{(64-3) {1'b0}},s_0}))];
  // index end

  assign c$result_rec = \f'  ? \f'  : f2;

  // register begin
  always @(posedge \BitLogicCliqueWithBuffAndCounter.testBench_clk  or  posedge  \c$BitLogicCliqueWithBuffAndCounter.testBench_bindCsr ) begin : s_0_register
    if ( \c$BitLogicCliqueWithBuffAndCounter.testBench_bindCsr ) begin
      s_0 <= 3'd0;
    end else begin
      s_0 <= result_1;
    end
  end
  // register end

  // assert begin
  // pragma translate_off
  always @(posedge \BitLogicCliqueWithBuffAndCounter.testBench_clk ) begin
    if (result_2 !== c$ds_app_arg_1) begin
      $display("@%0tns: %s, expected: %b, actual: %b", $time, ("outputVerifier"), c$ds_app_arg_1, result_2);
      $finish;
    end
  end
  // pragma translate_on
  assign f2 = \f' ;
  // assert end

  // register begin
  always @(posedge \BitLogicCliqueWithBuffAndCounter.testBench_clk  or  posedge  \c$BitLogicCliqueWithBuffAndCounter.testBench_bindCsr ) begin : f_register
    if ( \c$BitLogicCliqueWithBuffAndCounter.testBench_bindCsr ) begin
      \f'  <= 1'b0;
    end else begin
      \f'  <= (s_0 == 3'd5);
    end
  end
  // register end

  // register begin
  always @(posedge \BitLogicCliqueWithBuffAndCounter.testBench_clk  or  posedge  \c$BitLogicCliqueWithBuffAndCounter.testBench_bindCsr ) begin : c$ds_app_arg_2_register
    if ( \c$BitLogicCliqueWithBuffAndCounter.testBench_bindCsr ) begin
      c$ds_app_arg_2 <= {2'd1,   1'b0,   1'b0};
    end else begin
      c$ds_app_arg_2 <= result_3[9:6];
    end
  end
  // register end

  assign result_2 = result_3[5:0];

  always @(*) begin
    case(cnt)
      2'd3 : c$app_arg = 2'd1;
      default : c$app_arg = cnt + 2'd1;
    endcase
  end

  assign c$case_alt = ((complexOrSimple == (1'b0)) & ((prev1 == (1'b0)) & (prev2 == (1'b0)))) ? (1'b1) : (1'b0);

  always @(*) begin
    case(cnt)
      2'd3 : c$app_arg_0 = c$case_alt;
      default : c$app_arg_0 = 1'b0;
    endcase
  end

  assign result_3 = {{c$app_arg,
                      complexOrSimple,   prev1},   {result_4[4:4],
                                                    result_4[3:3],   result_4[2:2],
                                                    result_4[1:1],   complexOrSimple,
                                                    c$app_arg_0}};

  assign cnt = c$ds_app_arg_2[3:2];

  assign prev1 = c$ds_app_arg_2[1:1];

  assign prev2 = c$ds_app_arg_2[0:0];

  assign complexOrSimple = result_4[0:0];

  assign p = c$ds_app_arg_0[4:4];

  assign q = c$ds_app_arg_0[3:3];

  assign r = c$ds_app_arg_0[2:2];

  assign s_1 = c$ds_app_arg_0[1:1];

  assign t = c$ds_app_arg_0[0:0];

  assign xorResult = ((p ^ q) ^ r) ^ s_1;

  assign common = t & xorResult;

  assign result_4 = {common & p,   common & q,
                     common & r,   common & s_1,
                     t & (~ xorResult)};

  // resetGen begin
  // pragma translate_off
  reg  rst;
  localparam reset_period = 100000 - 10 + (1 * 100000);
  `ifndef VERILATOR
  initial begin
    #1 rst =  1 ;
    #reset_period rst =  0 ;
  end
  `else
  always begin
    // The redundant (rst | ~ rst) is needed to ensure that this is
    // calculated in every cycle by verilator. Without it, the reset will stop
    // being updated and will be stuck as asserted forever.
    rst = $c("this->reset_gen(",reset_period,",true)") & (rst | ~ rst);
  end
  `systemc_interface
  CData reset_gen(vluint32_t reset_period, bool active_high) {
    static vluint32_t to_wait = reset_period;
    static CData reset = active_high ? 1 : 0;
    static bool finished = false;

    if(!finished) {
      if(to_wait == 0) {
        reset = reset == 0 ? 1 : 0;
        finished = true;
      }
      else {
        to_wait = to_wait - 1;
      }
    }

    return reset;
  }
  `verilog
  `endif
  assign \c$BitLogicCliqueWithBuffAndCounter.testBench_bindCsr  = rst;
  // pragma translate_on
  // resetGen end

  assign result = c$result_rec;


endmodule

