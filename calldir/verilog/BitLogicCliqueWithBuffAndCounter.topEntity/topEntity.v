/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.6.5. DO NOT MODIFY.
*/
`timescale 100fs/100fs
module topEntity
    ( // Inputs
      input  clk // clock
    , input  rst // reset
    , input  en // enable
    , input  c$arg_0
    , input  c$arg_1
    , input  c$arg_2
    , input  c$arg_3
    , input  c$arg_4

      // Outputs
    , output wire  result_0
    , output wire  result_1
    , output wire  result_2
    , output wire  result_3
    , output wire  result_4
    , output wire  result_5
    );
  // ../clique4.hs:(45,1)-(48,46)
  reg [3:0] c$ds_app_arg = {2'd1,   1'b0,   1'b0};
  reg [1:0] c$app_arg;
  wire  c$case_alt;
  reg  c$app_arg_0;
  wire [9:0] result_12;
  // ../clique4.hs:28:1-35
  wire [1:0] cnt;
  // ../clique4.hs:28:1-35
  wire  prev1;
  // ../clique4.hs:28:1-35
  wire  prev2;
  // ../clique4.hs:28:1-35
  wire  complexOrSimple;
  // ../clique4.hs:11:1-32
  wire  p;
  // ../clique4.hs:11:1-32
  wire  q;
  // ../clique4.hs:11:1-32
  wire  r;
  // ../clique4.hs:11:1-32
  wire  s;
  // ../clique4.hs:11:1-32
  wire  t;
  // ../clique4.hs:11:1-32
  wire  xorResult;
  // ../clique4.hs:11:1-32
  wire  common;
  wire [4:0] result_13;
  wire [4:0] c$arg;
  wire [5:0] result;

  assign c$arg = {c$arg_0,   c$arg_1,
                  c$arg_2,   c$arg_3,   c$arg_4};

  // register begin
  always @(posedge clk or  posedge  rst) begin : c$ds_app_arg_register
    if ( rst) begin
      c$ds_app_arg <= {2'd1,   1'b0,   1'b0};
    end else if (en) begin
      c$ds_app_arg <= result_12[9:6];
    end
  end
  // register end

  assign result = result_12[5:0];

  always @(*) begin
    case(cnt)
      2'd3 : c$app_arg = 2'd1;
      default : c$app_arg = cnt + 2'd1;
    endcase
  end

  assign c$case_alt = ((complexOrSimple == (1'b0)) & ((prev1 == (1'b0)) & (prev2 == (1'b0)))) ? (1'b1) : (1'b0);

  always @(*) begin
    case(cnt)
      2'd3 : c$app_arg_0 = c$case_alt;
      default : c$app_arg_0 = 1'b0;
    endcase
  end

  assign result_12 = {{c$app_arg,
                       complexOrSimple,   prev1},   {result_13[4:4],
                                                     result_13[3:3],   result_13[2:2],
                                                     result_13[1:1],   complexOrSimple,
                                                     c$app_arg_0}};

  assign cnt = c$ds_app_arg[3:2];

  assign prev1 = c$ds_app_arg[1:1];

  assign prev2 = c$ds_app_arg[0:0];

  assign complexOrSimple = result_13[0:0];

  assign p = c$arg[4:4];

  assign q = c$arg[3:3];

  assign r = c$arg[2:2];

  assign s = c$arg[1:1];

  assign t = c$arg[0:0];

  assign xorResult = ((p ^ q) ^ r) ^ s;

  assign common = t & xorResult;

  assign result_13 = {common & p,   common & q,
                      common & r,   common & s,   t & (~ xorResult)};

  assign result_0 = result[5:5];

  assign result_1 = result[4:4];

  assign result_2 = result[3:3];

  assign result_3 = result[2:2];

  assign result_4 = result[1:1];

  assign result_5 = result[0:0];


endmodule

